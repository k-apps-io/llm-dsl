import { Agent } from "./Agent";

export namespace LLM {
  export type Metadata = Record<string, unknown> & {
    $: {
      version: string;
      parent?: string;
    };
  };

  export type Locals = Record<string, any>;

  export type Settings = {
    windowSize: number;
    minResponseSize: number;
    maxCallStack: number;
  };

  export const DEFAULT_SETTINGS: Settings = {
    windowSize: 4000,
    minResponseSize: 400,
    maxCallStack: 10,
  };

  /**
   * Interface representing a code block.
   * @interface
   */
  export interface CodeBlock {
    /** 
     * The language of the code block.
     * @type {string}
     */
    lang: string;

    /** 
     * The code content of the code block.
     * @type {string}
     */
    code: string;
  }

  export interface WindowOptions {
    chat: Agent<LLM.Model.Options, LLM.Model.Prompts, LLM.Model.Responses, LLM.Model.ToolResults>;
    messages: LLM.Chat<any>[ "messages" ];
    tokenLimit: number;
  }

  export type Window = ( options: WindowOptions ) => LLM.Message.Message<any, any, any, any>[];

  /** 
  * An enum representing the different visibility statuses a message can hold.
  * @enum {number}
  */
  export enum Visibility {
    /**
     * This is the default option.
     * It represents a message that can be excluded from the context window. This exclusion
     * would be implemneted in a Window function.
     */
    OPTIONAL,
    /**
     * same as optional however the message is tagged as a system level message. This 
     * may be helpful for messages that are system level e.g. a function resopnse a user may n
     */
    SYSTEM,
    REQUIRED, // will always be included in the context window
    EXCLUDE // will be removed from the context window
  }

  export namespace Model {
    export type Options = Record<string, any>;
    export type Prompts = Record<string, any>;
    export type Responses = Record<string, any>;
    export type ToolResults = Record<string, any>;

    export abstract class Service<
      O extends Options,
      P extends Prompts,
      R extends Responses,
      T extends ToolResults
    > {

      constructor() { }
      /**
       * cacluates the total number of tokens for a string
       * 
       * @param {string} text : a string to evaluate the number of tokens
       * @returns {number} : the number of tokens in the string
       */
      abstract tokens( content: Message.Message<O, P, R, T> ): number;

      /**
       * cacluates the total number of tokens for a window of Messages. This window is to be provided as additional input for a prompt.
       * 
       * @param {Message[]} window : a list 
       * @returns {number} : the total number of tokens created by the window.
       */
      abstract windowTokens( window: Message.Message<O, P, R, T>[] ): number;

      /**
       * cacluates the total number of tokens for a list of Functions
       * 
       * @param {Function[]} functions : a list 
       * @returns {Object} : the total number of tokens for the Function list in addition to key value pars of
       * each function name and the tokens created by that function.
       */
      abstract functionTokens( functions: Omit<Tool.Tool<O, P, R, T>, "func">[] ): { total: number;[ key: string ]: number; };

      /**
       * creates an iterable stream of the LLM response. The chunks of the stream will
       * either be text or a function to be called
       * 
       * @param {Stream} config 
       * 
       */
      abstract stream( config: Stream.Args<O, P, R, T> ): AsyncIterable<Stream.Response>;

      /**
       * a hook to close the LLM cleaning up any resources that may have been opened.
       */
      abstract close(): void;
    }

  }

  /**
   * Interface representing a chat.
   * @interface
   */
  export interface Chat<O extends Model.Options = Model.Options, P extends Model.Prompts = Model.Prompts, R extends Model.Responses = Model.Responses, T extends Model.ToolResults = Model.ToolResults, M extends Metadata = Metadata> {
    /** 
     * Unique identifier of the chat (optional).
     * @type {string}
     */
    id?: string;

    /**
     * Contains the sidebar ids spawned by the chat.
     * @type {string[]}
     */
    sidebars: string[];

    /**
     * Contains the list of messages in the chat.
     * @type {Message[]}
     */
    messages: Message.Message<O, P, R, T>[];

    /**
     * a id associated with a user whom created the chat
     */
    user?: string;

    /**
     * optional metadata to associate with the chat
     */
    metadata: M;

    /**
     * the total number of input tokens reviewed by the LLM
     */
    inputs: number;

    /**
     * the total number of output tokens generated by LLM responses
     */
    outputs: number;
  }

  export namespace Message {

    interface Base {
      /** 
       * Unique identifier of the message (optional).
       * @type {string}
       */
      id: string;

      type: string;

      /**
       * The key of the message (optional).
       * @type {string}
       */
      key?: string;

      /**
       * The visibility status of the message.
       * @type {Visibility}
       */
      visibility: Visibility;

      /**
       * The time the message was created.
       * @type {Date}
       */
      createdAt: Date;

      tokens: {
        message: number;
      };
    };

    export interface Prompt<O extends Model.Options, P extends Model.Prompts> extends Base {
      type: "prompt";

      options?: O;
      prompt: P;

      /**
       * The code blocks contained within the message (optional).
       * @type {CodeBlock[]}
       */
      codeBlocks?: CodeBlock[];

      user?: string;
    };

    interface Response extends Omit<Base, "tokens"> {
      tokens: {
        message: number;
        input: number;
      };

      window: string[];
      tools?: string[];

      prompt: string;
    }

    export interface TextResponse extends Response {
      type: "response";

      /**
       * The code blocks contained within the message (optional).
       * @type {CodeBlock[]}
       */
      codeBlocks?: CodeBlock[];

      text: string;
    };

    export interface FunctionResponse extends Response {
      type: "function";
      function: {
        name: string;
        arguments?: string;
      };
      call_id?: string;
    };

    export interface ToolResult<T extends Model.ToolResults> extends Base {
      type: "tool";
      call_id?: string;
      result: T;
    };

    export interface Instruction extends Base {
      type: "instruction";
      /**
       * The content of the instruction.
       * @type {string}
       */
      instruction: string;
    };

    export interface Error extends Base {
      type: "error";

      error: string;
    };

    export interface Rule extends Base {
      type: "rule";

      /**
       * The content of the rule.
       * @type {string}
       */
      rule: string;
    };

    export interface Context extends Base {
      type: "context";

      context: string;

      user?: string;
    }


    export type Message<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults> =
      | Prompt<O, P>
      | TextResponse
      | FunctionResponse
      | ToolResult<T>
      | Instruction
      | Error
      | Rule
      | Context;
  }

  export namespace Tool {

    export interface Tool<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata, A = Record<string, any>> {
      name: string;
      parameters: { [ key: string ]: any; };
      description: string;
      func: Stage.Function<O, P, R, T, L, M, T, A & { locals: L; chat: Agent<O, P, R, T, L, M>; tool_call_id?: string; }>;
    }
  }

  export namespace Stage {

    export interface FunctionArgs<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> {
      locals: Locals;
      chat: Agent<O, P, R, T, L, M>;
    }

    export type Function<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals, M extends Metadata, Result, A extends Record<string, any> = {}> = ( args: FunctionArgs<O, P, R, T, L, M> & A ) => Result | Promise<Result>;

    export interface Sidebar {
      rules?: true;
      functions?: true;
      locals?: true;
    }

    export interface ContextArgs extends Omit<Message.Context, "id" | "type" | "createdAt" | "size" | "user" | "visibility" | "tokens"> {
      visibility?: Visibility;
    }

    export type Push<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = ContextArgs | Function<O, P, R, T, L, M, ContextArgs>;

    export type Append<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = ContextArgs | Function<O, P, R, T, L, M, ContextArgs>;

    export interface PromptArgs<O extends Model.Options, P extends Model.Prompts> extends Omit<Message.Prompt<O, P>, "id" | "type" | "createdAt" | "size" | "user" | "windowSize" | "window" | "visibility" | "responseSize" | "tokens"> {
      visibility?: Visibility;
      responseSize?: number;
    }

    export type Prompt<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = PromptArgs<O, P> | Function<O, P, R, T, L, M, PromptArgs<O, P>>;

    export interface Send<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> {
      chat: Agent<O, P, R, T, L, M>;
      functions?: true;
      windowSize?: number;
      responseSize?: number;
      caller: string;
      options?: O;
    }

    export type PromptForEach<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = Function<O, P, R, T, L, M, ( PromptArgs<O, P> )[]>;

    export interface RuleArgs extends Omit<Message.Rule, "id" | "type" | "createdAt" | "rule" | "visibility" | "tokens"> {
      name: string;
      requirement: string;
      visibility?: Visibility;
    }

    export type Rule<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = RuleArgs | Function<O, P, R, T, L, M, RuleArgs>;

    export interface InstructionFileArgs {
      filepath: string;
    }

    export type Instruction = string | InstructionFileArgs;

    export interface CallArgs<F> {
      name: string;
      args?: F;
      generateResponse?: true;
    }

    export type Call<F> = CallArgs<F>;

    export type Response<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = Function<O, P, R, T, L, M, void, { response: Message.Message<O, P, R, T>; }>;

    export interface ExpectErrorResult {
      type: "error";
      error: string;
    }

    export type Expect<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata, E extends Record<string, any> = {}, A extends Record<string, any> = {}> = Function<O, P, R, T, L, M, ExpectErrorResult | E | void, { response: Message.TextResponse; } & A>;


    export type Pause<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = Function<O, P, R, T, L, M, void>;

    export interface MoveToArgs {
      id: string;
    }

    export type MoveTo<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = MoveToArgs | Function<O, P, R, T, L, M, MoveToArgs>;

    export type ForEach<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata, I = any> = Function<O, P, R, T, L, M, void, { item: I, index: number; }>;

    export type SetLocals<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = L | Function<O, P, R, T, L, M, L>;
    export type SetMetadata<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> = M | Function<O, P, R, T, L, M, M>;
  }

  export namespace Stream {

    export interface Args<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, L extends Locals = Locals, M extends Metadata = Metadata> {
      user?: string;
      messages: Message.Message<O, P, R, T>[];
      functions: Omit<Tool.Tool<O, P, R, T, L, M>, "func">[];
      options?: O;
    }

    export interface BaseResponse {
      type: string;
    }

    export interface UsageResponse extends BaseResponse {
      type: "usage";
      tokens: {
        input: number;
        output: number;
      };
    }

    export interface TextResponse extends BaseResponse {
      type: "text";
      text: string;
    }

    export interface ToolResponse extends BaseResponse {
      type: "tool";
      function: {
        name: string;
        arguments?: string;
      };
      call_id?: string;
    }

    export type Response = TextResponse | ToolResponse | UsageResponse;

    export interface ChunkBase {
      id: string;
      type: string;
      chat: string;
    }
    export interface StateChunk extends ChunkBase {
      state: "open" | "closed";
      type: "chat" | "sidebar";
    }
    export interface MetadataChunk<M extends Metadata> extends ChunkBase {
      type: "metadata";
      metadata: M;
    }

    export interface ResponseStreamChunk extends ChunkBase {
      type: "stream";
      text: string;
    }

    export interface MessageChunk<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults> extends ChunkBase {
      type: "message";
      message: Message.Message<O, P, R, T>;
    }

    export interface StageChunk extends ChunkBase {
      type: "stage";
      stage: string;
      state: "begin" | "end";
    }

    export type Chunk<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, M extends Metadata> = StateChunk | MetadataChunk<M> | ResponseStreamChunk | MessageChunk<O, P, R, T> | StageChunk;
    export type Handler<O extends Model.Options, P extends Model.Prompts, R extends Model.Responses, T extends Model.ToolResults, M extends Metadata> = ( chunk: Chunk<O, P, R, T, M> ) => void;
  }

  export namespace Storage {

    export abstract class Service {
      abstract newId(): string;

      abstract getById( id: string ): Promise<Chat>;

      abstract save( chat: Chat ): Promise<void>;

      abstract getArtifact( id: string ): Promise<Artifact | undefined>;

      abstract getArtifacts( ids: string[] ): Promise<Artifact[]>;

      abstract createArtifact( artifact: Omit<Artifact, "id"> ): Promise<Artifact>;

      abstract createArtifacts( artifacts: Omit<Artifact, "id">[] ): Promise<Artifact[]>;

      abstract updateArtifact( artifact: Artifact ): Promise<void>;

      abstract updateArtifacts( artifacts: Artifact[] ): Promise<void>;

      abstract deleteArtifact( id: string ): Promise<void>;

      abstract deleteArtifacts( ids: string[] ): Promise<void>;
    }
  }

  export type Artifact = {
    id: string;
    content: Buffer;
  };

}